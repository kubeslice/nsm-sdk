#!/bin/bash +x
# shellcheck disable=SC2002,SC2181

# Copyright (c) 2020 Doc.ai and/or its affiliates.
#
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

LINE="$*"

###########################
## Parse arguments
###########################

OUTPUT=
TYPE=
while [[ $# -gt 0 ]]; do
  if [[ "$1" == "-output" ]]; then
    OUTPUT="$2"
    shift 2
  elif [[ "$1" == "-type" ]]; then
    TYPE="$2"
    shift 2
  else
    echo "usage: $0 -output file.gen.go -type name<isClient,type>" && exit 1
  fi
done

if [[ "${OUTPUT}" == "" ]] || [[ "${TYPE}" == "" ]]; then
  echo "usage: $0 -output file.gen.go -type name<isClient,type>" && exit 1
fi

###########################
## Parse package
###########################

ls gen.go >/dev/null 2>/dev/null
if [[ $? -ne 0 ]]; then
  echo "no gen.go file found" && exit 2
fi
package="$(cat gen.go | grep -e "package .*" | sed -E "s/package (.*)/\1/g")"

###########################
## Prepare types
###########################

name=$(echo "${TYPE}" | sed -E "s/(.*)<.*>/\1/g")
is_client=$(echo "${TYPE}" | sed -E "s/.*<(.*),.*>/\1/g")
type=$(echo "${TYPE}" | sed -E "s/.*<.*,(.*)>/\1/g")

type_package=$(echo "${type}" | sed -E "s/\**(.*\/.*)\..*/\1/g")
type_name=$(echo "${type}" | sed -E "s/(\**).*\/(.*\..*)/\1\2/g")
if [[ "${type_name}" != "${type_package}" ]]; then
  type="${type_name}"
fi

type_formatted=$(echo "${type}" | sed -E "s/[\*\.\/]/_/g")

###########################
## Code
###########################

echo \
  "// Code generated by \"${LINE}\"; DO NOT EDIT.
package ${package}

import (
	\"context\"
	\"sync\"" >"${OUTPUT}"
if [[ "${type_name}" != "${type_package}" ]]; then
  echo \
    "
	\"${type_package}\"" >>"${OUTPUT}"
fi
echo \
  "
	\"github.com/networkservicemesh/sdk/pkg/networkservice/utils/metadata\"
)

const (
	${type_formatted}Key ${type_formatted}KeyType = \"${type_formatted}\"
)

type ${type_formatted}KeyType string

var _nil_${type_formatted} = func() (val ${type}) { return }()

type ${name}MetadataHelper struct {
	m *sync.Map
}

func ${name}MetaData(ctx context.Context) *${name}MetadataHelper {
	return &${name}MetadataHelper{
		m: metadata.Map(ctx, ${is_client}),
	}
}

func (h *${name}MetadataHelper) Store(value ${type}) {
	h.m.Store(${type_formatted}Key, value)
}

func (h *${name}MetadataHelper) LoadOrStore(value ${type}) (${type}, bool) {
	raw, ok := h.m.LoadOrStore(${type_formatted}Key, value)
	return raw.(${type}), ok
}

func (h *${name}MetadataHelper) Load() (${type}, bool) {
	if raw, ok := h.m.Load(${type_formatted}Key); ok {
		return raw.(${type}), true
	}
	return _nil_${type_formatted}, false
}

func (h *${name}MetadataHelper) LoadAndDelete() (${type}, bool) {
	if raw, ok := h.m.LoadAndDelete(${type_formatted}Key); ok {
		return raw.(${type}), true
	}
	return _nil_${type_formatted}, false
}

func (h *${name}MetadataHelper) Delete() {
	h.m.Delete(${type_formatted}Key)
}" >>"${OUTPUT}"
